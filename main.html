<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Maze Pathfinding</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        select, button {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #45a049;
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .maze-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 10px auto;
        }
        .results {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .stat-label {
            font-weight: bold;
            color: #555;
        }
        .stat-value {
            color: #2196F3;
            font-weight: bold;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 14px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-box {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }
        .ascii-output {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre;
            margin-top: 15px;
        }
        @media (max-width: 900px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1> A* Pathfinding Algorithm</h1>
    
    <div class="controls">
        <div class="control-group">
            <label>Maze Size:</label>
            <select id="mazeSize">
                <option value="10">Easy (10×10)</option>
                <option value="20" selected>Medium (20×20)</option>
                <option value="30">Hard (30×30)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Obstacle Density:</label>
            <select id="density">
                <option value="0.2">Low (20%)</option>
                <option value="0.3" selected>Medium (30%)</option>
                <option value="0.4">High (40%)</option>
            </select>
        </div>
        <div class="control-group">
            <button onclick="generateMaze()"> Generate New Maze</button>
            <button onclick="runAStar()"> Run A* Algorithm</button>
            <button onclick="downloadResults()"> Download Results</button>
        </div>
    </div>

    <div class="content">
        <div class="maze-container">
            <h3>Maze Visualization</h3>
            <canvas id="mazeCanvas" width="500" height="500"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-box" style="background: black;"></div>
                    <span>Wall (#)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: white;"></div>
                    <span>Path (.)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: #4CAF50;"></div>
                    <span>Start (S)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: #f44336;"></div>
                    <span>Goal (G)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: #FFD700;"></div>
                    <span>Solution (*)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box" style="background: #E3F2FD;"></div>
                    <span>Explored</span>
                </div>
            </div>
        </div>

        <div class="results">
            <h3>A* Algorithm Results</h3>
            <div id="status" class="status">Ready to run. Click "Run A* Algorithm" to start.</div>
            
            <div id="stats" style="display:none;">
                <div class="stat">
                    <span class="stat-label">Path Found:</span>
                    <span class="stat-value" id="pathFound">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Path Length:</span>
                    <span class="stat-value" id="pathLength">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Nodes Explored:</span>
                    <span class="stat-value" id="nodesExplored">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Time Taken:</span>
                    <span class="stat-value" id="timeTaken">-</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Efficiency:</span>
                    <span class="stat-value" id="efficiency">-</span>
                </div>
            </div>

            <h3>ASCII Representation</h3>
            <div id="asciiOutput" class="ascii-output">Generate a maze to see ASCII output...</div>
        </div>
    </div>

    <script>
        let maze = [];
        let rows = 20, cols = 20;
        let start = {x: 1, y: 1};
        let goal = {x: 18, y: 18};
        let path = [];
        let explored = [];

        class PriorityQueue {
            constructor() {
                this.items = [];
            }
            enqueue(item, priority) {
                this.items.push({item, priority});
                this.items.sort((a, b) => a.priority - b.priority);
            }
            dequeue() {
                return this.items.shift()?.item;
            }
            isEmpty() {
                return this.items.length === 0;
            }
        }

        function generateMaze() {
            const size = parseInt(document.getElementById('mazeSize').value);
            const density = parseFloat(document.getElementById('density').value);
            
            rows = cols = size;
            maze = [];
            
            // Initialize maze
            for (let i = 0; i < rows; i++) {
                maze[i] = [];
                for (let j = 0; j < cols; j++) {
                    maze[i][j] = Math.random() < density ? 1 : 0;
                }
            }
            
            // Set start and goal
            start = {x: 1, y: 1};
            goal = {x: rows - 2, y: cols - 2};
            maze[start.y][start.x] = 0;
            maze[goal.y][goal.x] = 0;
            
            // Clear paths
            path = [];
            explored = [];
            
            // Update display
            drawMaze();
            updateASCII();
            document.getElementById('stats').style.display = 'none';
            document.getElementById('status').innerHTML = 'Maze generated! Click "Run A* Algorithm" to find the path.';
        }

        function heuristic(a, b) {
            // Manhattan distance
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(node) {
            const neighbors = [];
            const dirs = [{x:0,y:-1}, {x:1,y:0}, {x:0,y:1}, {x:-1,y:0}];
            
            for (let dir of dirs) {
                const nx = node.x + dir.x;
                const ny = node.y + dir.y;
                
                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && maze[ny][nx] === 0) {
                    neighbors.push({x: nx, y: ny});
                }
            }
            return neighbors;
        }

        function runAStar() {
            const startTime = performance.now();
            
            explored = [];
            path = [];
            
            const openSet = new PriorityQueue();
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            const startKey = `${start.x},${start.y}`;
            const goalKey = `${goal.x},${goal.y}`;
            
            gScore.set(startKey, 0);
            fScore.set(startKey, heuristic(start, goal));
            openSet.enqueue(start, fScore.get(startKey));
            
            let nodesExplored = 0;
            
            while (!openSet.isEmpty()) {
                const current = openSet.dequeue();
                const currentKey = `${current.x},${current.y}`;
                
                nodesExplored++;
                explored.push({x: current.x, y: current.y});
                
                if (current.x === goal.x && current.y === goal.y) {
                    // Reconstruct path
                    let temp = current;
                    while (temp) {
                        path.unshift({x: temp.x, y: temp.y});
                        const key = `${temp.x},${temp.y}`;
                        temp = cameFrom.get(key);
                    }
                    
                    const endTime = performance.now();
                    displayResults(true, path.length, nodesExplored, endTime - startTime);
                    drawMaze();
                    updateASCII();
                    return;
                }
                
                closedSet.add(currentKey);
                
                const neighbors = getNeighbors(current);
                for (let neighbor of neighbors) {
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    
                    if (closedSet.has(neighborKey)) continue;
                    
                    const tentativeGScore = gScore.get(currentKey) + 1;
                    
                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        const f = tentativeGScore + heuristic(neighbor, goal);
                        fScore.set(neighborKey, f);
                        openSet.enqueue(neighbor, f);
                    }
                }
            }
            
            const endTime = performance.now();
            displayResults(false, 0, nodesExplored, endTime - startTime);
            drawMaze();
        }

        function displayResults(found, pathLen, nodesExp, time) {
            document.getElementById('stats').style.display = 'block';
            document.getElementById('pathFound').textContent = found ? 'Yes ✓' : 'No ✗';
            document.getElementById('pathLength').textContent = found ? pathLen : 'N/A';
            document.getElementById('nodesExplored').textContent = nodesExp;
            document.getElementById('timeTaken').textContent = time.toFixed(2) + ' ms';
            document.getElementById('efficiency').textContent = found ? 
                ((pathLen / nodesExp) * 100).toFixed(1) + '%' : 'N/A';
            
            const status = document.getElementById('status');
            if (found) {
                status.innerHTML = ` Path found! A* explored ${nodesExp} nodes to find a path of length ${pathLen}.`;
                status.style.background = '#e8f5e9';
                status.style.borderLeftColor = '#4CAF50';
            } else {
                status.innerHTML = ' No path exists between start and goal.';
                status.style.background = '#ffebee';
                status.style.borderLeftColor = '#f44336';
            }
        }

        function drawMaze() {
            const canvas = document.getElementById('mazeCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = Math.min(500 / cols, 500 / rows);
            
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw explored nodes
            for (let node of explored) {
                if ((node.x !== start.x || node.y !== start.y) && 
                    (node.x !== goal.x || node.y !== goal.y)) {
                    ctx.fillStyle = '#E3F2FD';
                    ctx.fillRect(node.x * cellSize, node.y * cellSize, cellSize, cellSize);
                }
            }
            
            // Draw maze
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (maze[i][j] === 1) {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    }
                    ctx.strokeStyle = '#ddd';
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
            
            // Draw path
            for (let i = 0; i < path.length; i++) {
                const node = path[i];
                if ((node.x !== start.x || node.y !== start.y) && 
                    (node.x !== goal.x || node.y !== goal.y)) {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(node.x * cellSize, node.y * cellSize, cellSize, cellSize);
                }
            }
            
            // Draw start
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(start.x * cellSize, start.y * cellSize, cellSize, cellSize);
            
            // Draw goal
            ctx.fillStyle = '#f44336';
            ctx.fillRect(goal.x * cellSize, goal.y * cellSize, cellSize, cellSize);
        }

        function updateASCII() {
            let ascii = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (j === start.x && i === start.y) {
                        ascii += 'S ';
                    } else if (j === goal.x && i === goal.y) {
                        ascii += 'G ';
                    } else if (path.some(p => p.x === j && p.y === i)) {
                        ascii += '* ';
                    } else if (maze[i][j] === 1) {
                        ascii += '# ';
                    } else {
                        ascii += '. ';
                    }
                }
                ascii += '\n';
            }
            document.getElementById('asciiOutput').textContent = ascii;
        }

        function downloadResults() {
            const stats = document.getElementById('stats');
            if (stats.style.display === 'none') {
                alert('Please run the algorithm first!');
                return;
            }
            
            let content = 'A* PATHFINDING RESULTS\n';
            content += '='.repeat(50) + '\n\n';
            content += 'Configuration:\n';
            content += `Maze Size: ${rows}×${cols}\n`;
            content += `Obstacle Density: ${document.getElementById('density').value}\n\n`;
            content += 'Results:\n';
            content += `Path Found: ${document.getElementById('pathFound').textContent}\n`;
            content += `Path Length: ${document.getElementById('pathLength').textContent}\n`;
            content += `Nodes Explored: ${document.getElementById('nodesExplored').textContent}\n`;
            content += `Time Taken: ${document.getElementById('timeTaken').textContent}\n`;
            content += `Efficiency: ${document.getElementById('efficiency').textContent}\n\n`;
            content += 'ASCII Maze:\n';
            content += document.getElementById('asciiOutput').textContent;
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'astar_results.txt';
            a.click();
        }

        // Initialize on load
        generateMaze();
    </script>
</body>
</html>